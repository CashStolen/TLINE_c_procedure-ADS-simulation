#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

typedef struct {
    double Vs;
    double Rs_int;
    double Z0;
    double vp;
    double len;
    double Rl_base;

    int    N;            // segments
    double cfl;          // dt = cfl*dx/vp (<=1)

    double t_end_factor_td;
    double t_end_factor_tr;

    double t_detail_factor_td;   // detail window = factor*Td (saved at every step)
    double t_detail_factor_tr;   // also consider factor*tr

    long   max_save_points;      // cap points after detail window (approx)
} SimParams;

typedef enum {
    TERM_NONE = 1,
    TERM_SRC_SER = 2,
    TERM_LOAD_PAR = 3,
    TERM_BOTH = 4
} TermMode;

static const char* mode_name(TermMode m) {
    switch (m) {
        case TERM_NONE:     return "none";
        case TERM_SRC_SER:  return "src_series";
        case TERM_LOAD_PAR: return "load_parallel";
        case TERM_BOTH:     return "both";
        default:            return "unknown";
    }
}

static double smooth_step(double t, double tr, double Vs) {
    if (t <= 0.0) return 0.0;
    if (t >= tr)  return Vs;
    return Vs * (0.5 - 0.5 * cos(M_PI * t / tr));
}

static void simulate_one(const SimParams* p, TermMode mode, double tr_s) {
    const int N = p->N;
    const double dx = p->len / (double)N;

    // Lossless line:
    // L' = Z0/vp, C' = 1/(Z0*vp)
    const double Lp = p->Z0 / p->vp;
    const double Cp = 1.0 / (p->Z0 * p->vp);

    const double Lseg = Lp * dx;
    const double Cseg = Cp * dx;

    const double dt = p->cfl * dx / p->vp;  // stable if cfl<=1

    // Node capacitances (endpoints half)
    double* Cnode = (double*)calloc((size_t)(N + 1), sizeof(double));
    for (int i = 0; i <= N; i++) Cnode[i] = Cseg;
    Cnode[0] = 0.5 * Cseg;
    Cnode[N] = 0.5 * Cseg;

    // State: V^n, I^{n-1/2}
    double* V  = (double*)calloc((size_t)(N + 1), sizeof(double));
    double* In = (double*)calloc((size_t)N, sizeof(double));
    double* Ip = (double*)calloc((size_t)N, sizeof(double));

    // Terminations
    double Rs_total = p->Rs_int;
    double Rser_ext = 0.0;
    double Rl_eff   = p->Rl_base;
    double Rpar_ext = INFINITY;

    if (mode == TERM_SRC_SER || mode == TERM_BOTH) {
        if (p->Z0 > p->Rs_int) Rser_ext = p->Z0 - p->Rs_int;
        Rs_total = p->Rs_int + Rser_ext;
    }
    if (mode == TERM_LOAD_PAR || mode == TERM_BOTH) {
        Rpar_ext = p->Z0;
        Rl_eff = 1.0 / (1.0/p->Rl_base + 1.0/Rpar_ext);
    }

    const double Td = p->len / p->vp;

    double t_end = p->t_end_factor_td * Td;
    if (p->t_end_factor_tr * tr_s > t_end) t_end = p->t_end_factor_tr * tr_s;
    if (t_end < 10.0*Td) t_end = 10.0*Td;

    // Detail window (save every step here)
    double t_detail = p->t_detail_factor_td * Td;
    if (p->t_detail_factor_tr * tr_s > t_detail) t_detail = p->t_detail_factor_tr * tr_s;
    if (t_detail < 5.0*Td) t_detail = 5.0*Td;     // at least a few bounces
    if (t_detail > t_end) t_detail = t_end;

    const long steps = (long)ceil(t_end / dt);
    const long detail_steps = (long)ceil(t_detail / dt);

    // After detail window, decimate so remaining points <= max_save_points (roughly)
    long save_every_after = 1;
    if (p->max_save_points > 0) {
        long remaining_steps = steps - detail_steps;
        if (remaining_steps > 0) {
            // allow about max_save_points points for the remaining part
            save_every_after = (long)ceil((double)remaining_steps / (double)p->max_save_points);
            if (save_every_after < 1) save_every_after = 1;
        }
    }

    char fname[256];
    if (tr_s < 1e-9) {
        snprintf(fname, sizeof(fname), "tl_%s_tr%.0fps.csv", mode_name(mode), tr_s * 1e12);
    } else {
        snprintf(fname, sizeof(fname), "tl_%s_tr%.0fns.csv", mode_name(mode), tr_s * 1e9);
    }

    FILE* fp = fopen(fname, "w");
    if (!fp) {
        fprintf(stderr, "Cannot open output file: %s\n", fname);
        free(Cnode); free(V); free(In); free(Ip);
        return;
    }
    fprintf(fp, "t_ns,V_source,V_mid,V_load\n");

    printf("Run: %s  tr=%.3g s | N=%d dt=%.3g s steps=%ld | detail=%.3g s (%ld steps) | decim_after=%ld\n",
           mode_name(mode), tr_s, N, dt, steps, t_detail, detail_steps, save_every_after);

    for (long n = 0; n <= steps; n++) {
        const double t_n   = (double)n * dt;
        const double t_np1 = (double)(n + 1) * dt;

        // Current update (half-step)
        for (int i = 0; i < N; i++) {
            Ip[i] = In[i] + (dt / Lseg) * (V[i] - V[i + 1]);
        }

        // Interior voltage update
        for (int i = 1; i < N; i++) {
            V[i] = V[i] + (dt / Cnode[i]) * (Ip[i - 1] - Ip[i]);
        }

        // Source boundary (semi-implicit solve for V0^{n+1})
        const double Vin_np1 = smooth_step(t_np1, tr_s, p->Vs);
        const double a0 = (Cnode[0] / dt) + (1.0 / Rs_total);
        const double b0 = (Cnode[0] / dt) * V[0] + (Vin_np1 / Rs_total) - Ip[0];
        V[0] = b0 / a0;

        // Load boundary (semi-implicit solve for VN^{n+1})
        const double aN = (Cnode[N] / dt) + (1.0 / Rl_eff);
        const double bN = (Cnode[N] / dt) * V[N] + Ip[N - 1];
        V[N] = bN / aN;

        // Advance currents
        for (int i = 0; i < N; i++) In[i] = Ip[i];

        // Save policy:
        // - always save all points in [0, t_detail]
        // - after that, save every save_every_after steps
        int do_save = 0;
        if (n <= detail_steps) {
            do_save = 1;
        } else {
            if ((n - detail_steps) % save_every_after == 0) do_save = 1;
        }

        if (do_save) {
            fprintf(fp, "%.6f,%.6f,%.6f,%.6f\n", t_n * 1e9, V[0], V[N/2], V[N]);
        }
    }

    fclose(fp);
    free(Cnode); free(V); free(In); free(Ip);

    printf("  -> wrote %s\n\n", fname);
}

int main(void) {
    SimParams p;
    p.Vs = 1.0;
    p.Rs_int = 20.0;
    p.Z0 = 50.0;
    p.vp = 2.0e8;
    p.len = 0.1;
    p.Rl_base = 1e6;

    // Spatial + time resolution
    p.N = 400;
    p.cfl = 0.95;

    // Total simulation time (long enough to see reflections; also cover slow edges)
    p.t_end_factor_td = 20.0;
    p.t_end_factor_tr = 6.0;

    // Detail window (dense sampling so early reflections are visible)
    p.t_detail_factor_td = 40.0;  // 40*Td = 20ns (with Td=0.5ns)
    p.t_detail_factor_tr = 2.0;   // also keep detail for first 2*tr if tr is large

    // After detail window, cap remaining saved points
    p.max_save_points = 60000;

    const double trs[3] = { 0.2e-9, 0.2e-8, 0.2e-6 };

    for (int k = 0; k < 3; k++) {
        for (int m = 1; m <= 4; m++) {
            simulate_one(&p, (TermMode)m, trs[k]);
        }
    }

    printf("All simulations done.\n");
    return 0;
}

